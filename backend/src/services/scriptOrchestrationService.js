// backend/src/services/scriptOrchestrationService.js

// This will be the refactored/renamed scriptGenerationService.js in the future.
// For now, it directly uses the existing service which handles LLM interaction.
const llmService = require('./scriptGenerationService');
const trendDiscoveryService = require('./trendDiscoveryService'); // Import TrendDiscoveryService
const supabase = require('../config/supabaseClient'); // G.O.A.T. C.O.D.E.X. B.O.T. - Import Supabase client

class ScriptOrchestrationService {
  /**
   * Orchestrates the entire process of creating a video script.
   * @param {string} topic - The main topic for the script.
   * @param {Array<Object>} initialTrends - Optional. An array of initial trend objects.
   * @returns {Promise<string>} The generated script text.
   * @throws {Error} If script generation fails at any critical step.
   */
  async orchestrateScriptCreation(topic, initialTrends = []) {
    console.log(
      `[OrchestrationService] Starting script creation for topic: "${topic}"`
    );

    // Step 1: Trend Discovery & Enrichment
    console.log('[OrchestrationService] Invoking Trend Discovery Service...');
    let discoveredTrends = [];
    try {
      discoveredTrends = await trendDiscoveryService.discoverTrends(topic);
      console.log(
        `[OrchestrationService] Trend Discovery Service returned ${discoveredTrends.length} trends.`
      );
    } catch (error) {
      console.error(
        '[OrchestrationService] Error during trend discovery:',
        error
      );
      // Decide how to handle trend discovery failure. For now, proceed with initialTrends if any.
      // In a real app, you might re-throw, or have a fallback.
    }

    // Combine initialTrends with discoveredTrends. For now, let's assume discoveredTrends are primary if available.
    // A more sophisticated merging strategy could be implemented later.
    const comprehensiveTrends =
      discoveredTrends.length > 0 ? discoveredTrends : initialTrends;
    console.log(
      '[OrchestrationService] Trends prepared for LLM:',
      comprehensiveTrends
    );

    // Step 2: LLM Script Generation
    // The llmService (currently scriptGenerationService) is responsible for constructing
    // the appropriate prompt and interacting with the LLM.
    console.log(
      '[OrchestrationService] Invoking LLM service for script generation...'
    );
    let scriptText;
    try {
      scriptText = await llmService.generateScript(topic, comprehensiveTrends);
      console.log(
        '[OrchestrationService] Script successfully generated by LLM service.'
      );
    } catch (error) {
      console.error(
        '[OrchestrationService] Error during LLM script generation:',
        error
      );
      // Re-throw the error to be handled by the controller or a higher-level error handler
      throw new Error(`Failed to generate script via LLM: ${error.message}`);
    }

    // Step 3: Post-processing (Placeholder)
    // Future enhancements could include formatting the script, adding standard intros/outros,
    // or other content modifications.
    console.log('[OrchestrationService] Script post-processing (placeholder).');

    // Step 4: Return the final script
    return scriptText;
  }

  /**
   * Orchestrates the modification of an existing script with selected keywords.
   * @param {string} existingScript - The script content to be modified.
   * @param {Array<string>} selectedKeywords - An array of keywords to infuse into the script.
   * @returns {Promise<string>} The modified script text.
   * @throws {Error} If script modification fails.
   */
  async orchestrateScriptModification(
    existingScript,
    selectedKeywords,
    userId = null
  ) {
    // G.O.A.T. C.O.D.E.X. B.O.T. - Added userId parameter
    console.log(
      `[OrchestrationService] Starting script modification with ${selectedKeywords.length} keywords.`
    );

    // Construct a detailed instructional prompt for the LLM.
    // This prompt will be passed as the "topic" to the llmService.generateScript method,
    // and selectedKeywords will be passed as "trends".
    const instructionalTopic = `Please modify the following script by naturally and coherently infusing the provided keywords. 
Maintain the original tone and intent of the script as much as possible. Focus on enhancing the script with these keywords, not rewriting it entirely.

Keywords to infuse: ${selectedKeywords.join(', ')}

Existing Script to Modify:
---
${existingScript}
---

Return only the modified script content.`;

    console.log(
      '[OrchestrationService] Invoking LLM service for script modification...'
    );
    let modifiedScriptText;
    try {
      // We use the existing llmService.generateScript method.
      // The 'instructionalTopic' contains the core task and the script.
      // 'selectedKeywords' are passed as 'trends' which the LLM prompt within generateScript can reference.
      modifiedScriptText = await llmService.generateScript(
        instructionalTopic,
        selectedKeywords.map((kw) => ({ keyword: kw, source: 'user-selected' }))
      );
      console.log(
        '[OrchestrationService] Script successfully modified by LLM service.'
      );
    } catch (error) {
      console.error(
        '[OrchestrationService] Error during LLM script modification:',
        error.message,
        error.stack
      );
      // Re-throw a more specific error to be handled by the controller
      throw new Error(
        `Failed to get valid modified script content: ${error.message}`
      );
    }

    // Future post-processing for modified script could go here.
    console.log(
      '[OrchestrationService] Modified script post-processing (placeholder).'
    );

    // G.O.A.T. C.O.D.E.X. B.O.T. - Save the modified script to Supabase
    try {
      const scriptDataToSave = {
        generated_script: modifiedScriptText,
        topic: `Modified: ${existingScript.substring(0, 75)}...`,
        trends_used: selectedKeywords.map((keyword) => ({
          keyword,
          source: 'user_input_for_modification',
        })),
        user_id: userId,
        // Add any other relevant fields, e.g., a type field to distinguish modified scripts
      };

      const { data: savedScript, error: saveError } = await supabase
        .from('scripts')
        .insert(scriptDataToSave)
        .select('id')
        .single();

      if (saveError) {
        console.error(
          '[OrchestrationService] Error saving modified script to Supabase:',
          saveError
        );
        throw new Error(
          `Failed to save modified script to database: ${saveError.message}`
        );
      }

      console.log(
        `[OrchestrationService] Modified script saved with ID: ${savedScript.id}`
      );
      return { modifiedScriptText, savedScriptId: savedScript.id };
    } catch (dbError) {
      console.error(
        '[OrchestrationService] Database operation failed during script modification saving:',
        dbError
      );
      // Re-throw or handle as appropriate. For now, re-throwing to be caught by controller.
      throw dbError; // This ensures the controller gets a clear error if DB save fails.
    }
  }
}

module.exports = new ScriptOrchestrationService();
